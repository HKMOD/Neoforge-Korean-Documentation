"use strict";(self.webpackChunkneoforged_docs=self.webpackChunkneoforged_docs||[]).push([[4655],{7765:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var s=n(5893),t=n(1151);const o={},l="Sides",a={id:"concepts/sides",title:"Sides",description:"Like many other programs, Minecraft follows a client-server concept, where the client is responsible for displaying the data, while the server is responsible for updating them. When using these terms, we have a fairly intuitive understanding of what we mean... right?",source:"@site/versioned_docs/version-1.20.4/concepts/sides.md",sourceDirName:"concepts",slug:"/concepts/sides",permalink:"/Neoforge-Korean-Documentation/en/docs/1.20.4/concepts/sides",draft:!1,unlisted:!1,tags:[],version:"1.20.4",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Registries",permalink:"/Neoforge-Korean-Documentation/en/docs/1.20.4/concepts/registries"},next:{title:"Advancement Generation",permalink:"/Neoforge-Korean-Documentation/en/docs/1.20.4/datagen/advancements"}},r={},c=[{value:"Logical vs. Physical Side",id:"logical-vs-physical-side",level:2},{value:"The Physical Side",id:"the-physical-side",level:3},{value:"The Logical Side",id:"the-logical-side",level:3},{value:"What&#39;s the Difference?",id:"whats-the-difference",level:3},{value:"Performing Side-Specific Operations",id:"performing-side-specific-operations",level:2},{value:"<code>Level#isClientSide()</code>",id:"levelisclientside",level:3},{value:"<code>FMLEnvironment.dist</code>",id:"fmlenvironmentdist",level:3}];function h(e){const i={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.h1,{id:"sides",children:"Sides"}),"\n",(0,s.jsx)(i.p,{children:"Like many other programs, Minecraft follows a client-server concept, where the client is responsible for displaying the data, while the server is responsible for updating them. When using these terms, we have a fairly intuitive understanding of what we mean... right?"}),"\n",(0,s.jsx)(i.p,{children:"Turns out, not so much. A lot of the confusion stems from Minecraft having two different concepts of sides, depending on the context: the physical and the logical side."}),"\n",(0,s.jsx)(i.h2,{id:"logical-vs-physical-side",children:"Logical vs. Physical Side"}),"\n",(0,s.jsx)(i.h3,{id:"the-physical-side",children:"The Physical Side"}),"\n",(0,s.jsxs)(i.p,{children:["When you open your Minecraft launcher, select a Minecraft installation and press play, you boot up a ",(0,s.jsx)(i.strong,{children:"physical client"}),'. The word "physical" is used here in the sense of "this is a client program". This especially means that client-side functionality, such as all the rendering stuff, is available here and can be used as needed. In contrast, the ',(0,s.jsx)(i.strong,{children:"physical server"}),", also known as dedicated server, is what opens when you launch a Minecraft server JAR. While the Minecraft server comes with a rudimentary GUI, it is missing all client-only functionality. Most notably, this means that various client classes are missing from the server JAR. Calling these classes on the physical server will lead to missing class errors, i.e. crashes, so we need to safeguard against this."]}),"\n",(0,s.jsx)(i.h3,{id:"the-logical-side",children:"The Logical Side"}),"\n",(0,s.jsxs)(i.p,{children:["The logical side is mainly focused on the internal program structure of Minecraft. The ",(0,s.jsx)(i.strong,{children:"logical server"})," is where the game logic runs. Things like time and weather changing, entity ticking, entity spawning, etc. all run on the server. All kinds of data, such as inventory contents, are the server's responsibility as well. The ",(0,s.jsx)(i.strong,{children:"logical client"}),", on the other hand, is responsible for displaying everything there is to display. Minecraft keeps all the client code in an isolated ",(0,s.jsx)(i.code,{children:"net.minecraft.client"})," package, and runs it in a separate thread called the Render Thread, while everything else is considered common (i.e. client and server) code."]}),"\n",(0,s.jsx)(i.h3,{id:"whats-the-difference",children:"What's the Difference?"}),"\n",(0,s.jsx)(i.p,{children:"The difference between physical and logical sides is best exemplified by two scenarios:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["The player joins a ",(0,s.jsx)(i.strong,{children:"multiplayer"})," world. This is fairly straightforward: The player's physical (and logical) client connects to a physical (and logical) server somewhere else - the player does not care where; so long as they can connect, that's all the client knows of, and all the client needs to know."]}),"\n",(0,s.jsxs)(i.li,{children:["The player joins a ",(0,s.jsx)(i.strong,{children:"singleplayer"})," world. This is where things get interesting. The player's physical client spins up a logical server and then, now in the role of the logical client, connects to that logical server on the same machine. If you are familiar with networking, you can think of it as a connection to ",(0,s.jsx)(i.code,{children:"localhost"})," (only conceptually; there are no actual sockets or similar involved)."]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["These two scenarios also show the main problem with this: If a logical server can work with your code, that alone doesn't guarantee that a physical server will be able to work with as well. This is why you should always test with dedicated servers to check for unexpected behavior. ",(0,s.jsx)(i.code,{children:"NoClassDefFoundError"}),"s and ",(0,s.jsx)(i.code,{children:"ClassNotFoundException"}),"s due to incorrect client and server separation are among the most common errors there are in modding. Another common mistake is working with static fields and accessing them from both logical sides; this is particularly tricky because there's usually no indication that something is wrong."]}),"\n",(0,s.jsx)(i.admonition,{type:"tip",children:(0,s.jsxs)(i.p,{children:["If you need to transfer data from one side to another, you must ",(0,s.jsx)(i.a,{href:"/Neoforge-Korean-Documentation/en/docs/1.20.4/networking/",children:"send a packet"}),"."]})}),"\n",(0,s.jsxs)(i.p,{children:["In the NeoForge codebase, the physical side is represented by an enum called ",(0,s.jsx)(i.code,{children:"Dist"}),", while the logical side is represented by an enum called ",(0,s.jsx)(i.code,{children:"LogicalSide"}),"."]}),"\n",(0,s.jsx)(i.admonition,{type:"info",children:(0,s.jsx)(i.p,{children:"Historically, server JARs have had classes the client did not. This is not the case anymore in modern versions; physical servers are a subset of physical clients, if you will."})}),"\n",(0,s.jsx)(i.h2,{id:"performing-side-specific-operations",children:"Performing Side-Specific Operations"}),"\n",(0,s.jsx)(i.h3,{id:"levelisclientside",children:(0,s.jsx)(i.code,{children:"Level#isClientSide()"})}),"\n",(0,s.jsxs)(i.p,{children:["This boolean check will be your most used way to check sides. Querying this field on a ",(0,s.jsx)(i.code,{children:"Level"})," object establishes the  ",(0,s.jsx)(i.strong,{children:"logical"})," side the level belongs to: If this field is ",(0,s.jsx)(i.code,{children:"true"}),", the level is running on the logical client. If the field is ",(0,s.jsx)(i.code,{children:"false"}),", the level is running on the logical server. It follows that the physical server will always contain ",(0,s.jsx)(i.code,{children:"false"})," in this field, but we cannot assume that ",(0,s.jsx)(i.code,{children:"false"})," implies a physical server, since this field can also be ",(0,s.jsx)(i.code,{children:"false"})," for the logical server inside a physical client (i.e. a singleplayer world)."]}),"\n",(0,s.jsxs)(i.p,{children:["Use this check whenever you need to determine if game logic and other mechanics should be run. For example, if you want to damage the player every time they click your block, or have your machine process dirt into diamonds, you should only do so after ensuring ",(0,s.jsx)(i.code,{children:"#isClientSide"})," is ",(0,s.jsx)(i.code,{children:"false"}),". Applying game logic to the logical client can cause desynchronization (ghost entities, desynchronized stats, etc.) in the best case, and crashes in the worst case."]}),"\n",(0,s.jsx)(i.admonition,{type:"tip",children:(0,s.jsxs)(i.p,{children:["This check should be used as your go-to default. Whenever you have a ",(0,s.jsx)(i.code,{children:"Level"})," available, use this check."]})}),"\n",(0,s.jsx)(i.h3,{id:"fmlenvironmentdist",children:(0,s.jsx)(i.code,{children:"FMLEnvironment.dist"})}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"FMLEnvironment.dist"})," is the ",(0,s.jsx)(i.strong,{children:"physical"})," counterpart to a ",(0,s.jsx)(i.code,{children:"Level#isClientSide()"})," check. If this field is ",(0,s.jsx)(i.code,{children:"Dist.CLIENT"}),", you are on a physical client. If the field is ",(0,s.jsx)(i.code,{children:"Dist.SERVER"}),", you are on a physical server."]}),"\n",(0,s.jsxs)(i.p,{children:["Checking the physical environment is important when dealing with client-only classes. All calls to client-only code should always be encased in a check for ",(0,s.jsx)(i.code,{children:"Dist.CLIENT"}),", and then call to a separate class to prevent accidental classloading:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:"public class SomeCommonClass {\n    public void someCommonMethod() {\n        //SomeClientClass will be loaded if and only if you are on a physical client\n        if (FMLEnvironment.dist == Dist.CLIENT) {\n            SomeClientClass.someClientMethod();\n        }\n    }\n}\n\npublic class SomeClientClass {\n    public void someClientMethod() {\n        Minecraft.getInstance().whatever();\n    }\n}\n"})}),"\n",(0,s.jsx)(i.admonition,{type:"tip",children:(0,s.jsx)(i.p,{children:"Mods are generally expected to work on either side. This especially means that if you are developing a client-only mod, you should verify that the mod actually runs on a physical client, and no-op in the event that it does not."})})]})}function d(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1151:(e,i,n)=>{n.d(i,{Z:()=>a,a:()=>l});var s=n(7294);const t={},o=s.createContext(t);function l(e){const i=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(o.Provider,{value:i},e.children)}}}]);