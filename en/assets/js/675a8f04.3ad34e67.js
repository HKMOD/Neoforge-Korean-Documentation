"use strict";(self.webpackChunkneoforged_docs=self.webpackChunkneoforged_docs||[]).push([[359],{4913:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var i=t(5893),o=t(1151);const r={},s="Root Transforms",a={id:"rendering/modelextensions/transforms",title:"Root Transforms",description:"Adding the transform entry at the top level of a model JSON suggests to the loader that a transformation should be applied to all geometry right before the rotations in the blockstate] file in the case of a block model, and before the [display transforms in the case of an item model. The transformation is available through IGeometryBakingContext#getRootTransform() in IUnbakedGeometry#bake().",source:"@site/docs/rendering/modelextensions/transforms.md",sourceDirName:"rendering/modelextensions",slug:"/rendering/modelextensions/transforms",permalink:"/Neoforge-Korean-Documentation/en/docs/rendering/modelextensions/transforms",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Render Types",permalink:"/Neoforge-Korean-Documentation/en/docs/rendering/modelextensions/rendertypes"},next:{title:"Part Visibility",permalink:"/Neoforge-Korean-Documentation/en/docs/rendering/modelextensions/visibility"}},l={},d=[{value:"Element-wise specification",id:"element-wise-specification",level:2},{value:"Origin",id:"origin",level:3},{value:"Translation",id:"translation",level:3},{value:"Left and Right Rotation",id:"left-and-right-rotation",level:3},{value:"Scale",id:"scale",level:3}];function c(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"root-transforms",children:"Root Transforms"}),"\n",(0,i.jsxs)(n.p,{children:["Adding the ",(0,i.jsx)(n.code,{children:"transform"})," entry at the top level of a model JSON suggests to the loader that a transformation should be applied to all geometry right before the rotations in the ",(0,i.jsx)(n.a,{href:"https://minecraft.wiki/w/Tutorials/Models#Block_states",children:"blockstate"})," file in the case of a block model, and before the ",(0,i.jsx)(n.a,{href:"/Neoforge-Korean-Documentation/en/docs/rendering/modelloaders/transform",children:"display transforms"})," in the case of an item model. The transformation is available through ",(0,i.jsx)(n.code,{children:"IGeometryBakingContext#getRootTransform()"})," in ",(0,i.jsx)(n.code,{children:"IUnbakedGeometry#bake()"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Custom model loaders may ignore this field entirely."}),"\n",(0,i.jsx)(n.p,{children:"The root transforms can be specified in two formats:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["A JSON object containing a singular ",(0,i.jsx)(n.code,{children:"matrix"})," entry containing a raw transformation matrix in the form of a nested JSON array with the last row omitted (3*4 matrix, row major order). The matrix is the composition of the translation, left rotation, scale, right rotation and the transformation origin in that order. Example demonstrating the structure:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'"transform": {\n    "matrix": [\n        [ 0, 0, 0, 0 ],\n        [ 0, 0, 0, 0 ],\n        [ 0, 0, 0, 0 ]\n    ]\n}\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["A JSON object containing any combination of the following optional entries:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"origin"}),": origin point used for the rotations and scaling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"translation"}),": relative translation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rotation"})," or ",(0,i.jsx)(n.code,{children:"left_rotation"}),": rotation around the translated origin to be applied before scaling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"scale"}),": scale relative to the translated origin"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"right_rotation"})," or ",(0,i.jsx)(n.code,{children:"post_rotation"}),": rotation around the translated origin to be applied after scaling"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"element-wise-specification",children:"Element-wise specification"}),"\n",(0,i.jsxs)(n.p,{children:["If the transformation is specified as a combination of the entries mentioned in option 4, these entries will be applied in the order of ",(0,i.jsx)(n.code,{children:"translation"}),", ",(0,i.jsx)(n.code,{children:"left_rotation"}),", ",(0,i.jsx)(n.code,{children:"scale"}),", ",(0,i.jsx)(n.code,{children:"right_rotation"}),".",(0,i.jsx)(n.br,{}),"\n","The transformation is moved to the specified origin as a last step."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'{\n    "transform": {\n        "origin": "center",\n        "translation": [ 0, 0.5, 0 ],\n        "rotation": { "y": 45 }\n    },\n    // ...\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The elements are expected to be defined as follows:"}),"\n",(0,i.jsx)(n.h3,{id:"origin",children:"Origin"}),"\n",(0,i.jsxs)(n.p,{children:["The origin can be specified either as an array of 3 floating point values representing a three-dimensional vector: ",(0,i.jsx)(n.code,{children:"[ x, y, z ]"})," or as one of the three default values:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"corner"'})," (0, 0, 0)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"center"'})," (.5, .5, .5)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"opposing-corner"'})," (1, 1, 1)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["If the origin is not specified, it defaults to ",(0,i.jsx)(n.code,{children:'"opposing-corner"'}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"translation",children:"Translation"}),"\n",(0,i.jsxs)(n.p,{children:["The translation must be specified as an array of 3 floating point values representing a three-dimensional vector: ",(0,i.jsx)(n.code,{children:"[ x, y, z ]"})," and defaults to (0, 0, 0) if not present."]}),"\n",(0,i.jsx)(n.h3,{id:"left-and-right-rotation",children:"Left and Right Rotation"}),"\n",(0,i.jsx)(n.p,{children:"The rotations can be specified in any one of the following four ways:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Single JSON object with a single axis => rotation degree mapping: ",(0,i.jsx)(n.code,{children:'{ "x": 90 }'})]}),"\n",(0,i.jsxs)(n.li,{children:["Array of an arbitrary amount of JSON objects with the above format (applied in the order they are specified in): ",(0,i.jsx)(n.code,{children:'[ { "x": 90 }, { "y": 45 }, { "x": -22.5 } ]'})]}),"\n",(0,i.jsxs)(n.li,{children:["Array of 3 floating point values specifying the rotation in degrees around each axis: ",(0,i.jsx)(n.code,{children:"[ 90, 180, 45 ]"})]}),"\n",(0,i.jsxs)(n.li,{children:["Array of 4 floating point values specifying a quaternion directly: ",(0,i.jsx)(n.code,{children:"[ 0.38268346, 0, 0, 0.9238795 ]"})," (example equals 45 degrees around the X axis)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If the respective rotation is not specified, it will default to no rotation."}),"\n",(0,i.jsx)(n.h3,{id:"scale",children:"Scale"}),"\n",(0,i.jsxs)(n.p,{children:["The scale must be specified as an array of 3 floating point values representing a three-dimensional vector: ",(0,i.jsx)(n.code,{children:"[ x, y, z ]"})," and defaults to (1, 1, 1) if not present."]})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>s});var i=t(7294);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);