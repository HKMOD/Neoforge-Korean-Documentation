"use strict";(self.webpackChunkneoforged_docs=self.webpackChunkneoforged_docs||[]).push([[5719],{1298:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var n=o(5893),r=o(1151);const i={},s="Tools & Armor",a={id:"items/tools",title:"Tools & Armor",description:"Tools are items whose primary use is to break blocks. Many mods add new tool sets (for example copper tools) or new tool types (for example hammers).",source:"@site/versioned_docs/version-1.20.4/items/tools.md",sourceDirName:"items",slug:"/items/tools",permalink:"/Neoforge-Korean-Documentation/docs/1.20.4/items/tools",draft:!1,unlisted:!1,tags:[],version:"1.20.4",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Mob Effects & Potions",permalink:"/Neoforge-Korean-Documentation/docs/1.20.4/items/mobeffects"},next:{title:"Porting to Minecraft 1.20",permalink:"/Neoforge-Korean-Documentation/docs/1.20.4/legacy/porting"}},l={},c=[{value:"Custom Tool Sets",id:"custom-tool-sets",level:2},{value:"Tags",id:"tags",level:3},{value:"<code>TierSortingRegistry</code>",id:"tiersortingregistry",level:3},{value:"Custom Tool Types",id:"custom-tool-types",level:2},{value:"<code>ToolAction</code>s",id:"toolactions",level:2},{value:"Armor",id:"armor",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"tools--armor",children:"Tools & Armor"}),"\n",(0,n.jsxs)(t.p,{children:["Tools are ",(0,n.jsx)(t.a,{href:"/Neoforge-Korean-Documentation/docs/1.20.4/items/",children:"items"})," whose primary use is to break ",(0,n.jsx)(t.a,{href:"/Neoforge-Korean-Documentation/docs/1.20.4/blocks/",children:"blocks"}),". Many mods add new tool sets (for example copper tools) or new tool types (for example hammers)."]}),"\n",(0,n.jsx)(t.h2,{id:"custom-tool-sets",children:"Custom Tool Sets"}),"\n",(0,n.jsxs)(t.p,{children:["A tool set typically consists of five items: a pickaxe, an axe, a shovel, a hoe and a sword. (Swords aren't tools in the classical sense, but are included here for consistency as well.) All of those items have their corresponding class: ",(0,n.jsx)(t.code,{children:"PickaxeItem"}),", ",(0,n.jsx)(t.code,{children:"AxeItem"}),", ",(0,n.jsx)(t.code,{children:"ShovelItem"}),", ",(0,n.jsx)(t.code,{children:"HoeItem"})," and ",(0,n.jsx)(t.code,{children:"SwordItem"}),", respectively. The class hierarchy of tools looks as follows:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-text",children:"Item\n- TieredItem\n  - DiggerItem\n    - AxeItem\n    - HoeItem\n    - PickaxeItem\n    - ShovelItem\n  - SwordItem\n"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"TieredItem"})," is a class that contains helpers for items with a certain ",(0,n.jsx)(t.code,{children:"Tier"})," (read on). ",(0,n.jsx)(t.code,{children:"DiggerItem"})," contains helpers for items that are designed to break blocks. Note that other items usually considered tools, such as shears, are not included in this hierarchy. Instead, they directly extend ",(0,n.jsx)(t.code,{children:"Item"})," and hold the breaking logic themselves."]}),"\n",(0,n.jsxs)(t.p,{children:["To create a standard set of tools, you must first define a ",(0,n.jsx)(t.code,{children:"Tier"}),". For reference values, see Minecraft's ",(0,n.jsx)(t.code,{children:"Tiers"})," enum. This example uses copper tools, you can use your own material here and adjust the values as needed."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:"// We place copper somewhere between stone and iron.\npublic static final Tier COPPER_TIER = new SimpleTier(\n        // Determines the level of this tool. Since this is an int, there is no good way to place our tool between stone and iron.\n        // NeoForge introduces the TierSortingRegistry to solve this problem, see below for more information. Use a best-effort approximation here.\n        // Stone is 1, iron is 2.\n        1,\n        // Determines the durability of the tier.\n        // Stone is 131, iron is 250.\n        200,\n        // Determines the mining speed of the tier. Unused by swords.\n        // Stone uses 4, iron uses 6.\n        5f,\n        // Determines the attack damage bonus. Different tools use this differently. For example, swords do (getAttackDamageBonus() + 4) damage.\n        // Stone uses 1, iron uses 2, corresponding to 5 and 6 attack damage for swords, respectively; our sword does 5.5 damage now.\n        1.5f,\n        // Determines the enchantability of the tier. This represents how good the enchantments on this tool will be.\n        // Gold uses 22, we put copper slightly below that.\n        20,\n        // The tag that determines what blocks this tool can break. See below for more information.\n        MyBlockTags.NEEDS_COPPER_TOOL,\n        // Determines the repair ingredient of the tier. Use a supplier for lazy initializing.\n        () -> Ingredient.of(Tags.Items.INGOTS_COPPER)\n);\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Now that we have our ",(0,n.jsx)(t.code,{children:"Tier"}),", we can use it for registering tools. All tool constructors have the same four parameters."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'//ITEMS is a DeferredRegister<Item>\npublic static final Supplier<SwordItem> COPPER_SWORD = ITEMS.register("copper_sword", () -> new SwordItem(\n        // The tier to use.\n        COPPER_TIER,\n        // The type-specific attack damage bonus. 3 for swords, 1.5 for shovels, 1 for pickaxes, varying for axes and hoes.\n        3,\n        // The type-specific attack speed modifier. The player has a default attack speed of 4, so to get to the desired\n        // value of 1.6f, we use -2.4f. -2.4f for swords, -3f for shovels, -2.8f for pickaxes, varying for axes and hoes.\n        -2.4f,\n        // The item properties. We don\'t need to set the durability here because TieredItem handles that for us.\n        new Item.Properties()\n));\npublic static final Supplier<AxeItem> COPPER_AXE = ITEMS.register("copper_axe", () -> new AxeItem(...));\npublic static final Supplier<PickaxeItem> COPPER_PICKAXE = ITEMS.register("copper_pickaxe", () -> new PickaxeItem(...));\npublic static final Supplier<ShovelItem> COPPER_SHOVEL = ITEMS.register("copper_shovel", () -> new ShovelItem(...));\npublic static final Supplier<HoeItem> COPPER_HOE = ITEMS.register("copper_hoe", () -> new HoeItem(...));\n'})}),"\n",(0,n.jsx)(t.h3,{id:"tags",children:"Tags"}),"\n",(0,n.jsxs)(t.p,{children:["When creating a ",(0,n.jsx)(t.code,{children:"Tier"}),", it is assigned a block ",(0,n.jsx)(t.a,{href:"/Neoforge-Korean-Documentation/docs/1.20.4/resources/server/tags",children:"tag"})," containing blocks that need this tool (or a better one) to be broken. For example, the ",(0,n.jsx)(t.code,{children:"minecraft:needs_iron_tool"})," tag contains Diamond Ores (among others), and the ",(0,n.jsx)(t.code,{children:"minecraft:needs_diamond_tool"})," tag contains blocks like Obsidian and Ancient Debris."]}),"\n",(0,n.jsxs)(t.p,{children:["You can reuse one of these tags for your tool if you're fine with that. For example, if we wanted our copper tools to just be more durable stone tools, we'd pass in ",(0,n.jsx)(t.code,{children:"BlockTags.NEEDS_STONE_TOOL"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"Alternatively, we can create our own tag, like so:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'public static final TagKey<Block> NEEDS_COPPER_TOOL = TagKey.create(BuiltInRegistries.BLOCK.key(), new ResourceLocation(MOD_ID, "needs_copper_tool"));\n'})}),"\n",(0,n.jsxs)(t.p,{children:["And then, we populate our tag. For example, let's make copper able to mine gold ores, gold blocks and redstone ore, but not diamonds or emeralds. (Redstone blocks are already mineable by stone tools.) The tag file is located at ",(0,n.jsx)(t.code,{children:"src/main/resources/data/mod_id/tags/blocks/needs_copper_tool.json"})," (where ",(0,n.jsx)(t.code,{children:"mod_id"})," is your mod id):"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n  "values": [\n    "minecraft:gold_block",\n    "minecraft:raw_gold_block",\n    "minecraft:gold_ore",\n    "minecraft:deepslate_gold_ore",\n    "minecraft:redstone_ore",\n    "minecraft:deepslate_redstone_ore"\n  ]\n}\n'})}),"\n",(0,n.jsx)(t.p,{children:"Finally, we can pass our tag into our tier creation, as seen above."}),"\n",(0,n.jsx)(t.h3,{id:"tiersortingregistry",children:(0,n.jsx)(t.code,{children:"TierSortingRegistry"})}),"\n",(0,n.jsxs)(t.p,{children:["In order to make the game actually pick up your tier as between two others, you must register it to the ",(0,n.jsx)(t.code,{children:"TierSortingRegistry"}),". This must happen before item registration, a ",(0,n.jsx)(t.code,{children:"static"})," initializer in the same class as your tier definition is a good spot for that. If you do not add your tier to the registry, it will fall back to what vanilla would do."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'public static final Tier COPPER_TIER = new SimpleTier(...);\n\nstatic {\n    TierSortingRegistry.registerTier(\n            COPPER_TIER,\n            //The name to use for internal resolution. May use the Minecraft namespace if appropriate.\n            new ResourceLocation("minecraft", "copper"),\n            //A list of tiers that are considered lower than the type being added. For example, stone is lower than copper.\n            //We don\'t need to add wood and gold here because those are already lower than stone.\n            List.of(Tiers.STONE),\n            //A list of tiers that are considered higher than the type being added. For example, iron is higher than copper.\n            //We don\'t need to add diamond and netherite here because those are already higher than iron.\n            List.of(Tiers.IRON)\n    );\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Instead of or in addition to a ",(0,n.jsx)(t.code,{children:"Tier"}),", you can also pass in other tiers' ids into these lists. For example, say we want to make our material be considered weaker than both iron and the Osmium tools from ",(0,n.jsx)(t.a,{href:"https://www.curseforge.com/minecraft/mc-mods/mekanism-tools",children:"Mekanism Tools"}),", we could do that like so:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'public static final Tier COPPER_TIER = new SimpleTier(...);\n\nstatic {\n    TierSortingRegistry.registerTier(\n            COPPER_TIER,\n            new ResourceLocation("minecraft", "copper"),\n            List.of(Tiers.STONE),\n            //We can mix and match Tiers and ResourceLocations here.\n            List.of(Tiers.IRON, new ResourceLocation("mekanism", "osmium"))\n    );\n}\n'})}),"\n",(0,n.jsx)(t.p,{children:"This works for both the lower and higher tiers. If multiple options are available, the system will choose the strictest bounds available."}),"\n",(0,n.jsx)(t.admonition,{type:"caution",children:(0,n.jsx)(t.p,{children:"Be aware that circular dependencies may occur if this is set up incorrectly, so make sure that your bounds actually make sense and don't all cross-reference one another."})}),"\n",(0,n.jsxs)(t.p,{children:["If you want to check if a tier is applicable for a block state, call ",(0,n.jsx)(t.code,{children:"TierSortingRegistry#isCorrectTierForDrops"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"custom-tool-types",children:"Custom Tool Types"}),"\n",(0,n.jsxs)(t.p,{children:["Custom tool types can be created by extending ",(0,n.jsx)(t.code,{children:"DiggerItem"})," (or ",(0,n.jsx)(t.code,{children:"TieredItem"})," if you are making custom weapon types). They don't need too big of a setup, it is an item class like any other, with all implications that has."]}),"\n",(0,n.jsxs)(t.p,{children:["One thing worth noting is the parameters of ",(0,n.jsx)(t.code,{children:"DiggerItem"}),". The first four parameters are the same as for its subclasses (see the explanation for ",(0,n.jsx)(t.code,{children:"SwordItem"})," above), while the fifth parameter is the ",(0,n.jsx)(t.code,{children:"mineable"})," tag for the tool type. Generally, the format here is ",(0,n.jsx)(t.code,{children:"<mod_id>:mineable/<tool_type>"}),", though ",(0,n.jsx)(t.code,{children:"forge"})," can be used as the namespace too if you expect other mods to add similar tools. For example, ",(0,n.jsx)(t.a,{href:"https://www.curseforge.com/minecraft/mc-mods/farmers-delight",children:"Farmer's Delight"})," uses a ",(0,n.jsx)(t.code,{children:"forge:mineable/knives"})," tag."]}),"\n",(0,n.jsxs)(t.p,{children:["If you plan on making a multitool-like item (i.e. an item that combines two or more tools into one, e.g. an axe and a pickaxe as one item), it is best to extend ",(0,n.jsx)(t.code,{children:"AxeItem"})," if applicable. This is because enchantment checks for things like Sharpness or Knockback are hardcoded to ",(0,n.jsx)(t.code,{children:"instanceof AxeItem"}),"."]}),"\n",(0,n.jsxs)(t.h2,{id:"toolactions",children:[(0,n.jsx)(t.code,{children:"ToolAction"}),"s"]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"ToolAction"}),"s are an abstraction over what a tool can and cannot do. This includes both left-click and right-click behavior. NeoForge provides default ",(0,n.jsx)(t.code,{children:"ToolAction"}),"s in the ",(0,n.jsx)(t.code,{children:"ToolActions"})," class:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Digging actions. These exist for all four ",(0,n.jsx)(t.code,{children:"DiggerItem"})," types as mentioned above, as well as sword and shears digging."]}),"\n",(0,n.jsx)(t.li,{children:"Axe right-click actions for stripping (logs), scraping (oxidized copper) and unwaxing (waxed copper)."}),"\n",(0,n.jsx)(t.li,{children:"Shear actions for harvesting (honeycombs), carving (pumpkins) and disarming (tripwires)."}),"\n",(0,n.jsx)(t.li,{children:"Actions for shovel flattening (dirt paths), sword sweeping, hoe tilling, shield blocking, and fishing rod casting."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["To create your own ",(0,n.jsx)(t.code,{children:"ToolAction"}),"s, use ",(0,n.jsx)(t.code,{children:"ToolAction#get"})," - it will create a new ",(0,n.jsx)(t.code,{children:"ToolAction"})," if needed. Then, in a custom tool type, override ",(0,n.jsx)(t.code,{children:"IItemExtension#canPerformAction"})," as needed."]}),"\n",(0,n.jsxs)(t.p,{children:["To query if an ",(0,n.jsx)(t.code,{children:"ItemStack"})," can perform a certain ",(0,n.jsx)(t.code,{children:"ToolAction"}),", call ",(0,n.jsx)(t.code,{children:"IItemStackExtension#canPerformAction"}),". Note that this works on any ",(0,n.jsx)(t.code,{children:"Item"}),", not just tools."]}),"\n",(0,n.jsx)(t.h2,{id:"armor",children:"Armor"}),"\n",(0,n.jsxs)(t.p,{children:["Similar to tools, armor uses a tier system (although a different one). What is called ",(0,n.jsx)(t.code,{children:"Tier"})," for tools is called ",(0,n.jsx)(t.code,{children:"ArmorMaterial"})," for armors. Like above, this example shows how to add copper armor; this can be adapted as needed. For the vanilla values, see the ",(0,n.jsx)(t.code,{children:"ArmorMaterials"})," enum."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'// We place copper somewhere between chainmail and iron.\npublic static final ArmorMaterial COPPER_ARMOR_MATERIAL = new ArmorMaterial() {\n    // The name of the armor material. Mainly determines where the armor texture is. Should contain\n    // a leading mod id to guarantee uniqueness, otherwise there may be issues when two mods\n    // try to add the same armor material. (If the mod id is omitted, the "minecraft" namespace will be used.)\n    @Override\n    public String getName() {\n        return "modid:copper";\n    }\n\n    // Override for StringRepresentable. Should generally return the same as getName().\n    @Override\n    public String getSerializedName() {\n        return getName();\n    }\n\n    // Determines the durability of this armor material, depending on what armor piece it is.\n    // ArmorItem.Type is an enum of four values: HELMET, CHESTPLATE, LEGGINGS and BOOTS.\n    // Vanilla armor materials determine this by using a base value and multiplying it with a type-specific constant.\n    // The constants are 13 for BOOTS, 15 for LEGGINGS, 16 for CHESTPLATE and 11 for HELMET.\n    // Both chainmail and iron use 15 as the base value, so we\'ll use it as well.\n    @Override\n    public int getDurabilityForType(ArmorItem.Type type) {\n        return switch (type) {\n            case HELMET -> 11 * 15;\n            case CHESTPLATE -> 16 * 15;\n            case LEGGINGS -> 15 * 15;\n            case BOOTS -> 13 * 15;\n        };\n    }\n\n    // Determines the defense value of this armor material, depending on what armor piece it is.\n    @Override\n    public int getDurabilityForType(ArmorItem.Type type) {\n        return switch (type) {\n            case HELMET -> 2;\n            case CHESTPLATE -> 4;\n            case LEGGINGS -> 6;\n            case BOOTS -> 2;\n        };\n    }\n\n    // Returns the toughness value of the armor. The toughness value is an additional value included in\n    // damage calculation, for more information, refer to the Minecraft Wiki\'s article on armor mechanics:\n    // https://minecraft.wiki/w/Armor#Armor_toughness\n    // Only diamond and netherite have values greater than 0 here, so we just return 0.\n    @Override\n    public float getToughness() {\n        return 0;\n    }\n\n    // Returns the knockback resistance value of the armor. While wearing this armor, the player is\n    // immune to knockback to some degree. If the player has a total knockback resistance value of 1 or greater\n    // from all armor pieces combined, they will not take any knockback at all.\n    // Only netherite has values greater than 0 here, so we just return 0.\n    @Override\n    public float getKnockbackResistance() {\n        return 0;\n    }\n\n    // Determines the enchantability of the tier. This represents how good the enchantments on this armor will be.\n    // Gold uses 25, we put copper slightly below that.\n    @Override\n    public int getEnchantmentValue(ArmorItem.Type type) {\n        return 20;\n    }\n\n    // Determines the sound played when equipping this armor.\n    @Override\n    public SoundEvent getEquipSound() {\n        return SoundEvents.ARMOR_EQUIP_GENERIC;\n    }\n\n    // Determines the repair item for this armor.\n    @Override\n    public Ingredient getRepairIngredient() {\n        return Ingredient.of(Tags.Items.INGOTS_COPPER);\n    }\n    \n    // Optionally, you can also override #getArmorTexture here. This method returns a ResourceLocation\n    // that determines where the armor location is stored, in case you want to store it in a non-default location.\n    // See the default implementation in Tier for an example.\n}\n'})}),"\n",(0,n.jsx)(t.p,{children:"And then, we use that armor material in item registration."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'//ITEMS is a DeferredRegister<Item>\npublic static final Supplier<ArmorItem> COPPER_HELMET = ITEMS.register("copper_helmet", () -> new ArmorItem(\n        // The armor material to use.\n        COPPER_ARMOR_MATERIAL,\n        // The armor type to use.\n        ArmorItem.Type.HELMET,\n        // The item properties. We don\'t need to set the durability here because ArmorItem handles that for us.\n        new Item.Properties()\n));\npublic static final Supplier<ArmorItem> COPPER_CHESTPLATE = ITEMS.register("copper_chestplate", () -> new ArmorItem(...));\npublic static final Supplier<ArmorItem> COPPER_LEGGINGS = ITEMS.register("copper_leggings", () -> new ArmorItem(...));\npublic static final Supplier<ArmorItem> COPPER_BOOTS = ITEMS.register("copper_boots", () -> new ArmorItem(...));\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Besides the usual resources, armors also need a worn armor texture that will be rendered over the player model when the armor is equipped. This texture must be located at ",(0,n.jsx)(t.code,{children:"src/main/resources/assets/<mod_id>/textures/models/armor/<material>_layer_1.png"})," for the helmet, chestplate and boots textures, and in the same directory at ",(0,n.jsx)(t.code,{children:"<material>_layer_2.png"})," for the leggings."]}),"\n",(0,n.jsx)(t.p,{children:"When creating your armor texture, it is a good idea to work on top of the vanilla armor texture to see which part goes where."})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},1151:(e,t,o)=>{o.d(t,{Z:()=>a,a:()=>s});var n=o(7294);const r={},i=n.createContext(r);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);