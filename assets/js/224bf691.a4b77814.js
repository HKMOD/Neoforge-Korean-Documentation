"use strict";(self.webpackChunkneoforged_docs=self.webpackChunkneoforged_docs||[]).push([[187],{9244:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=t(5893),o=t(1151);const i={},r="Extensible Enums",s={id:"advanced/extensibleenums",title:"Extensible Enums",description:"Extensible Enums are an enhancement of specific Vanilla enums to allow new entries to be added. This is done by modifying the compiled bytecode of the enum at runtime to add the elements.",source:"@site/docs/advanced/extensibleenums.md",sourceDirName:"advanced",slug:"/advanced/extensibleenums",permalink:"/Neoforge-Korean-Documentation/docs/advanced/extensibleenums",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Access Transformer",permalink:"/Neoforge-Korean-Documentation/docs/advanced/accesstransformers"},next:{title:"\ube14\ub85d \uc5d4\ud2f0\ud2f0",permalink:"/Neoforge-Korean-Documentation/docs/blockentities/"}},l={},c=[{value:"<code>IExtensibleEnum</code>",id:"iextensibleenum",level:2},{value:"Creating an Enum Entry",id:"creating-an-enum-entry",level:3},{value:"Contributing to NeoForge",id:"contributing-to-neoforge",level:2},{value:"The <code>init</code> method",id:"the-init-method",level:3},{value:"Codecs",id:"codecs",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"extensible-enums",children:"Extensible Enums"}),"\n",(0,a.jsx)(n.p,{children:"Extensible Enums are an enhancement of specific Vanilla enums to allow new entries to be added. This is done by modifying the compiled bytecode of the enum at runtime to add the elements."}),"\n",(0,a.jsx)(n.h2,{id:"iextensibleenum",children:(0,a.jsx)(n.code,{children:"IExtensibleEnum"})}),"\n",(0,a.jsxs)(n.p,{children:["All enums that can have new entries implement the ",(0,a.jsx)(n.code,{children:"IExtensibleEnum"})," interface. This interface acts as a marker to allow the ",(0,a.jsx)(n.code,{children:"RuntimeEnumExtender"})," launch plugin service to know what enums should be transformed."]}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:["You should ",(0,a.jsx)(n.strong,{children:"not"})," be implementing this interface on your own enums. Use maps or registries instead depending on your usecase."]})}),"\n",(0,a.jsx)(n.h3,{id:"creating-an-enum-entry",children:"Creating an Enum Entry"}),"\n",(0,a.jsxs)(n.p,{children:["To create a new enum entry, the static ",(0,a.jsx)(n.code,{children:"create"})," method should be called. This static method is added to all extensible enums and is transformed at runtime to allow new enums to be added."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"create"})," method should be called within a static final field if you need to refer to the value or within the main mod constructor if you do not."]})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"create"})," method contains a name parameter followed by the parameters of a supporting constructor. The name parameter represents the name of the enum constant, which is returned by ",(0,a.jsx)(n.code,{children:"#name"}),". The name of the enum constant should be prefixed with your mod id followed by an underscore (",(0,a.jsx)(n.code,{children:"_"}),") to avoid conflicts between mods that decide to add the same enum constant (e.g., adding a enum constant called ",(0,a.jsx)(n.code,{children:"test"})," with mod id ",(0,a.jsx)(n.code,{children:"examplemod"})," should be ",(0,a.jsx)(n.code,{children:"EXAMPLEMOD_TEST"}),")."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"Since extensible enums are added at runtime, technically, any UTF-8 character can be used for the name parameter. However, it is recommended to only use valid Java identifiers."})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// In your main mod class\npublic static final FireworkExplosion.Shape DUMMY =\n        FireworkExplosion.Shape.create("EXAMPLEMOD_DUMMY", 294, "examplemod_dummy");\n'})}),"\n",(0,a.jsx)(n.h2,{id:"contributing-to-neoforge",children:"Contributing to NeoForge"}),"\n",(0,a.jsx)(n.p,{children:"To add a new extensible enum to NeoForge, there are at least two required things to do."}),"\n",(0,a.jsxs)(n.p,{children:["First, have the enum implement ",(0,a.jsx)(n.code,{children:"IExtensibleEnum"})," to mark that this enum should be transformed via the ",(0,a.jsx)(n.code,{children:"RuntimeEnumExtender"}),". Second, add a ",(0,a.jsx)(n.code,{children:"create"})," method for every constructor within the enum. All create methods should start with a ",(0,a.jsx)(n.code,{children:"String"})," parameter representing the name of the enum constant. The ",(0,a.jsx)(n.code,{children:"create"})," methods should throw an ",(0,a.jsx)(n.code,{children:"IllegalStateException"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"create"})," method(s) will be transformed at runtime, so unless the enum was not detectable, the ",(0,a.jsx)(n.code,{children:"create"})," method will create a new enum entry."]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// This is an example, not an actual enum within Vanilla\npublic enum ExampleEnum implements net.neoforged.neoforge.common.IExtensibleEnum {\n    // VALUE_1 represents the name parameter here\n    VALUE_1(0, "value_1", false),\n    VALUE_2(1, "value_2", true),\n    VALUE_3(2, "value_3");\n\n    ExampleEnum(int arg1, String arg2, boolean arg3) {\n        // ...\n    }\n\n    ExampleEnum(int arg1, String arg2) {\n        this(arg1, arg2, false);\n    }\n\n    // Matches the first constructor\n    public static ExampleEnum create(String name, int arg1, String arg2, boolean arg3) {\n        throw new IllegalStateException("Enum not extended");\n    }\n\n    // Matches the second constructor\n    public static ExampleEnum create(String name, int arg1, String arg2) {\n        throw new IllegalStateException("Enum not extended");\n    }\n\n    // ...\n}\n'})}),"\n",(0,a.jsxs)(n.h3,{id:"the-init-method",children:["The ",(0,a.jsx)(n.code,{children:"init"})," method"]}),"\n",(0,a.jsxs)(n.p,{children:["Sometimes, an enum will do something with its constants or values after registration. However, as these instances statically call the associated entries, the values added via ",(0,a.jsx)(n.code,{children:"create"})," may not be referenced. To get around this, extensible enums can override the ",(0,a.jsx)(n.code,{children:"init"})," method to do any post-constructor setup required by the specific enum constant."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// As an example\npublic enum ExampleEnumInit {\n    VALUE_1(0, "value_1", false),\n    VALUE_2(1, "value_2", true);\n\n    private static final Map<String, boolean> ARG2_TO_ARG3 =\n        Arrays.stream(ExampleEnumInit.values())\n        .collect(\n            Collectors.toMap(\n                e -> e.arg2,\n                e -> e.arg3\n            )\n        );\n\n    ExampleEnumInit(int arg1, String arg2, boolean arg3) {\n        // ...\n    }\n}\n\n// The final extended enum may look something like this\npublic enum ExampleEnumInit implements net.neoforged.neoforge.common.IExtensibleEnum {\n    VALUE_1(0, "value_1", false),\n    VALUE_2(1, "value_2", true);\n\n    private static final Map<String, boolean> ARG2_TO_ARG3 =\n        Arrays.stream(ExampleEnumInit.values())\n        .collect(\n            Collectors.toMap(\n                e -> e.arg2,\n                e -> e.arg3\n            )\n        );\n\n    ExampleEnumInit(int arg1, String arg2, boolean arg3) {\n        // ...\n    }\n\n    // Matches the constructor\n    public static ExampleEnumInit create(String name, int arg1, String arg2, boolean arg3) {\n        throw new IllegalStateException("Enum not extended");\n    }\n\n    @Override\n    public void init() {\n        // Gets called for every new enum\n        ARG2_TO_ARG3.put(this.arg2, this.arg3);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"codecs",children:"Codecs"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"/Neoforge-Korean-Documentation/docs/datastorage/codecs",children:"Enum codecs"})," generally take in the ",(0,a.jsx)(n.code,{children:"values"})," array and resolve the codec instantly. As the array is evaluated before any mod entries are added, no mod entries will be supported. There are two solutions to this problem, which to choose depends on whether the enum implements the ",(0,a.jsx)(n.code,{children:"StringRepresentable"})," interface or not."]}),"\n",(0,a.jsxs)(n.p,{children:["For normal, non-",(0,a.jsx)(n.code,{children:"StringRepresentable"})," enums, the codec can be wrapped via ",(0,a.jsx)(n.code,{children:"Codec#lazyInitialized"})," or ",(0,a.jsx)(n.a,{href:"/Neoforge-Korean-Documentation/docs/networking/streamcodecs#vanilla-and-neoforge",children:(0,a.jsx)(n.code,{children:"NeoForgeStreamCodecs#lazy"})}),". These prevent the codec from being resolved until first usage, which will always be after all mod entries are added."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// For some enum with codec\npublic enum ExampleEnumCodec {\n    // ...\n    ;\n\n    public static final Codec<ExampleEnumCodec> CODEC = Codec.of(/* ... */);\n    public static final StreamCodec<ByteBuf, ExampleEnumCodec> CODEC = StreamCodec.of(/* ... */);\n\n    // ...\n}\n\n// The final extended enum may look something like this\npublic enum ExampleEnumCodec implements net.neoforged.neoforge.common.IExtensibleEnum {\n    // ...\n    ;\n\n    public static final Codec<ExampleEnumCodec> CODEC = Codec.lazyInitialized(\n        () -> Codec.of(/* ... */)\n    );\n    public static final StreamCodec<ByteBuf, ExampleEnumCodec> CODEC = \n        net.neoforged.neoforge.common.util.NeoForgeStreamCodecs.lazy(\n            () -> StreamCodec.of(/* ... */)\n        );\n\n    // ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["For ",(0,a.jsx)(n.code,{children:"StringRepresentable"})," enums, ",(0,a.jsx)(n.code,{children:"IExtensibleEnum"})," provides ",(0,a.jsx)(n.code,{children:"createCodecForExtensibleEnum"})," and ",(0,a.jsx)(n.code,{children:"createStreamCodecForExtensibleEnum"})," which do not cache the values at all, meaning they will always obtain up-to-date enums added at any point."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// For some enum with codec\npublic enum ExampleEnumStringCodec implements StringRepresentable {\n    // ...\n    ;\n\n    private static final IntFunction<ExampleEnumStringCodec> BY_ID = ByIdMap.continuous(\n        ExampleEnumStringCodec::getId, values(), ByIdMap.OutOfBoundsStrategy.ZERO\n    );\n\n    public static final Codec<ExampleEnumStringCodec> CODEC = StringRepresentable.fromEnum(ExampleEnumStringCodec::values);\n    public static final StreamCodec<ByteBuf, ExampleEnumStringCodec> CODEC = ByteBufCodecs.idMapper(BY_ID, ExampleEnumStringCodec::getId);\n\n    ExampleEnumStringCodec(int id, String serializedName) {\n        // ...\n    }\n\n    // ...\n}\n\n// The final extended enum may look something like this\npublic enum ExampleEnumStringCodec implements StringRepresentable, net.neoforged.neoforge.common.IExtensibleEnum {\n    // ...\n    ;\n\n    private static final java.util.Map<String, ExampleEnumStringCodec> BY_NAME = \n        java.util.Arrays.stream(ExampleEnumStringCodec.values())\n        .collect(java.util.stream.Collectors.toMap(\n            e -> e.serializedName, e -> e\n        ));\n\n\n    public static final Codec<ExampleEnumStringCodec> CODEC =\n        net.neoforged.neoforge.common.IExtensibleEnum.createCodecForExtensibleEnum(\n            ExampleEnumStringCodec::values, ExampleEnumStringCodec::byName\n        );\n    public static final StreamCodec<ByteBuf, ExampleEnumStringCodec> CODEC =\n        net.neoforged.neoforge.common.IExtensibleEnum.createStreamCodecForExtensibleEnum(ExampleEnumStringCodec::values);\n\n    ExampleEnumStringCodec(int id, String serializedName) {\n        // ...\n    }\n\n    @Override\n    public void init() {\n        BY_NAME.put(this.serializedName, this);\n    }\n\n    public static ExampleEnumStringCodec byName(String name) {\n        return BY_NAME.get(name);\n    }\n\n    // ...\n}\n"})})]})}function m(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>r});var a=t(7294);const o={},i=a.createContext(o);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);