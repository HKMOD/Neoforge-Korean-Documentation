"use strict";(self.webpackChunkneoforged_docs=self.webpackChunkneoforged_docs||[]).push([[5811],{4692:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=n(5893),i=n(1151);const o={},s="Entities",r={id:"networking/entities",title:"Entities",description:"In addition to regular network messages, there are various other systems provided to handle synchronizing entity data.",source:"@site/versioned_docs/version-1.20.4/networking/entities.md",sourceDirName:"networking",slug:"/networking/entities",permalink:"/Neoforge-Korean-Documentation/docs/1.20.4/networking/entities",draft:!1,unlisted:!1,tags:[],version:"1.20.4",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Using Configuration Tasks",permalink:"/Neoforge-Korean-Documentation/docs/1.20.4/networking/configuration-tasks"},next:{title:"Registering Payloads",permalink:"/Neoforge-Korean-Documentation/docs/1.20.4/networking/payload"}},d={},c=[{value:"Spawn Data",id:"spawn-data",level:2},{value:"IEntityWithComplexSpawn",id:"ientitywithcomplexspawn",level:3},{value:"Dynamic Data",id:"dynamic-data",level:2},{value:"Data Parameters",id:"data-parameters",level:3}];function l(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"entities",children:"Entities"}),"\n",(0,a.jsx)(t.p,{children:"In addition to regular network messages, there are various other systems provided to handle synchronizing entity data."}),"\n",(0,a.jsx)(t.h2,{id:"spawn-data",children:"Spawn Data"}),"\n",(0,a.jsx)(t.p,{children:"Since 1.20.2 Mojang introduced the concept of Bundle packets, which are used to send entity spawn packets together.\nThis allows for more data to be sent with the spawn packet, and for that data to be sent more efficiently."}),"\n",(0,a.jsx)(t.p,{children:"You can add extra data to the spawn packet NeoForge sends by implementing the following interface."}),"\n",(0,a.jsx)(t.h3,{id:"ientitywithcomplexspawn",children:"IEntityWithComplexSpawn"}),"\n",(0,a.jsxs)(t.p,{children:["If your entity has data that is needed on the client, but does not change over time, then it can be added to the entity spawn packet using this interface. ",(0,a.jsx)(t.code,{children:"#writeSpawnData"})," and ",(0,a.jsx)(t.code,{children:"#readSpawnData"})," control how the data should be encoded to/decoded from the network buffer.\nAlternatively you can override the method ",(0,a.jsx)(t.code,{children:"sendPairingData(...)"})," which is called when the entity is paired with a client. This method is called on the server, and can be used to send additional payloads to the client within the same bundle as the spawn packet."]}),"\n",(0,a.jsx)(t.h2,{id:"dynamic-data",children:"Dynamic Data"}),"\n",(0,a.jsx)(t.h3,{id:"data-parameters",children:"Data Parameters"}),"\n",(0,a.jsx)(t.p,{children:"This is the main vanilla system for synchronizing entity data from the server to the client. As such, a number of vanilla examples are available to refer to."}),"\n",(0,a.jsxs)(t.p,{children:["Firstly, you need a ",(0,a.jsx)(t.code,{children:"EntityDataAccessor<T>"})," for the data you wish to keep synchronized. This should be stored as a ",(0,a.jsx)(t.code,{children:"static final"})," field in your entity class, obtained by calling ",(0,a.jsx)(t.code,{children:"SynchedEntityData#defineId"})," and passing the entity class and a serializer for that type of data. The available serializer implementations can be found as static constants within the ",(0,a.jsx)(t.code,{children:"EntityDataSerializers"})," class."]}),"\n",(0,a.jsx)(t.admonition,{type:"caution",children:(0,a.jsxs)(t.p,{children:["You should ",(0,a.jsx)(t.strong,{children:"only"})," create data parameters for your own entities, ",(0,a.jsx)(t.em,{children:"within that entity's class"}),".\nAdding parameters to entities you do not control can cause the IDs used to send that data over the network to become desynchronized, causing difficult to debug crashes."]})}),"\n",(0,a.jsxs)(t.p,{children:["Then, override ",(0,a.jsx)(t.code,{children:"Entity#defineSynchedData"})," and call ",(0,a.jsx)(t.code,{children:"this.entityData.define(...)"})," for each of your data parameters, passing the parameter and an initial value to use. Remember to always call the ",(0,a.jsx)(t.code,{children:"super"})," method first!"]}),"\n",(0,a.jsxs)(t.p,{children:["You can then get and set these values via your entity's ",(0,a.jsx)(t.code,{children:"entityData"})," instance. Changes made will be synchronized to the client automatically."]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>s});var a=n(7294);const i={},o=a.createContext(i);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);