"use strict";(self.webpackChunkneoforged_docs=self.webpackChunkneoforged_docs||[]).push([[9542],{783:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>c});var t=i(5893),s=i(1151);const r={},o="The Interaction Pipeline",d={id:"items/interactionpipeline",title:"The Interaction Pipeline",description:"This page aims to make the fairly complex and confusing process of things being right-clicked by the player more understandable, as well as clarifying what result to use where and why.",source:"@site/docs/items/interactionpipeline.md",sourceDirName:"items",slug:"/items/interactionpipeline",permalink:"/Neoforge-Korean-Documentation/docs/items/interactionpipeline",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"BlockEntityWithoutLevelRenderer",permalink:"/Neoforge-Korean-Documentation/docs/items/bewlr"},next:{title:"\ub9c8\uc778\ud06c\ub798\ud504\ud2b8 1.20\uc73c\ub85c \uc5c5\uadf8\ub808\uc774\ub4dc \ud558\uae30",permalink:"/Neoforge-Korean-Documentation/docs/legacy/porting"}},l={},c=[{value:"What Happens When I Right-Click?",id:"what-happens-when-i-right-click",level:2},{value:"Result Types",id:"result-types",level:2},{value:"<code>IItemExtension#onItemUseFirst</code>",id:"iitemextensiononitemusefirst",level:2},{value:"<code>Item#useOn</code>",id:"itemuseon",level:2},{value:"<code>Item#use</code>",id:"itemuse",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"the-interaction-pipeline",children:"The Interaction Pipeline"}),"\n",(0,t.jsx)(n.p,{children:"This page aims to make the fairly complex and confusing process of things being right-clicked by the player more understandable, as well as clarifying what result to use where and why."}),"\n",(0,t.jsx)(n.h2,{id:"what-happens-when-i-right-click",children:"What Happens When I Right-Click?"}),"\n",(0,t.jsxs)(n.p,{children:["When you right-click anywhere in the world, a number of things happen, depending on what you are currently looking at and what ",(0,t.jsx)(n.code,{children:"ItemStack"}),'s are in your hands. A number of methods returning one of two result types (see below) are called. Most of these methods cancel the pipeline if an explicit success or an explicit failure is returned. For the sake of readability, this "explicit success or explicit failure" will be called a "definitive result" from now on.']}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"InputEvent.InteractionKeyMappingTriggered"})," is fired with the right mouse button and the main hand. If the event is canceled, the pipeline ends."]}),"\n",(0,t.jsxs)(n.li,{children:["Several circumstances are checked, for example that you are not in spectator mode or that all required feature flags for the ",(0,t.jsx)(n.code,{children:"ItemStack"})," in your main hand are enabled. If at least one of these checks fails, the pipeline ends."]}),"\n",(0,t.jsxs)(n.li,{children:["Depending on what you are looking at, different things happen:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If you are looking at an entity that is within your reach and not outside the world border:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PlayerInteractEvent.EntityInteractSpecific"})," is fired. If the event is canceled, the pipeline ends."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Entity#interactAt"})," will be called ",(0,t.jsx)(n.strong,{children:"on the entity you are looking at"}),". If it returns a definitive result, the pipeline ends.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If you want to add behavior for your own entity, override this method. If you want to add behavior for a vanilla entity, use the event."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"If the entity opens an interface (for example a villager trading GUI or a chest minecart GUI), the pipeline ends."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PlayerInteractEvent.EntityInteract"})," is fired. If the event is canceled, the pipeline ends."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Entity#interact"})," is called ",(0,t.jsx)(n.strong,{children:"on the entity you are looking at"}),". If it returns a definitive result, the pipeline ends.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If you want to add behavior for your own entity, override this method. If you want to add behavior for a vanilla entity, use the event."}),"\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.code,{children:"Mob"}),"s, the override of ",(0,t.jsx)(n.code,{children:"Entity#interact"})," handles things like leashing and spawning babies when the ",(0,t.jsx)(n.code,{children:"ItemStack"})," in your main hand is a spawn egg, and then defers mob-specific handling to ",(0,t.jsx)(n.code,{children:"Mob#mobInteract"}),". The rules for results for ",(0,t.jsx)(n.code,{children:"Entity#interact"})," apply here as well."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["If the entity you are looking at is a ",(0,t.jsx)(n.code,{children:"LivingEntity"}),", ",(0,t.jsx)(n.code,{children:"Item#interactLivingEntity"})," is called on the ",(0,t.jsx)(n.code,{children:"ItemStack"})," in your main hand. If it returns a definitive result, the pipeline ends."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["If you are looking at a block that is within your reach and not outside the world border:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PlayerInteractEvent.RightClickBlock"})," is fired. If the event is canceled, the pipeline ends. You may also specifically deny only block or item usage in this event."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"IItemExtension#onItemUseFirst"})," is called. If it returns a definitive result, the pipeline ends."]}),"\n",(0,t.jsxs)(n.li,{children:["If the player is not sneaking and the event does not deny block usage, ",(0,t.jsx)(n.code,{children:"Block#use"})," is called. If it returns a definitive result, the pipeline ends."]}),"\n",(0,t.jsxs)(n.li,{children:["If the event does not deny item usage, ",(0,t.jsx)(n.code,{children:"Item#useOn"})," is called. If it returns a definitive result, the pipeline ends."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Item#use"})," is called. If it returns a definitive result, the pipeline ends."]}),"\n",(0,t.jsx)(n.li,{children:"The above process runs a second time, this time with the off hand instead of the main hand."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"result-types",children:"Result Types"}),"\n",(0,t.jsxs)(n.p,{children:["There are two different types of results: ",(0,t.jsx)(n.code,{children:"InteractionResult"}),"s and ",(0,t.jsx)(n.code,{children:"InteractionResultHolder<T>"}),"s. ",(0,t.jsx)(n.code,{children:"InteractionResult"})," is used most of the time, only ",(0,t.jsx)(n.code,{children:"Item#use"})," uses ",(0,t.jsx)(n.code,{children:"InteractionResultHolder<ItemStack>"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"InteractionResult"})," is an enum consisting of five values: ",(0,t.jsx)(n.code,{children:"SUCCESS"}),", ",(0,t.jsx)(n.code,{children:"CONSUME"}),", ",(0,t.jsx)(n.code,{children:"CONSUME_PARTIAL"}),", ",(0,t.jsx)(n.code,{children:"PASS"})," and ",(0,t.jsx)(n.code,{children:"FAIL"}),". Additionally, the method ",(0,t.jsx)(n.code,{children:"InteractionResult#sidedSuccess"})," is available, which returns ",(0,t.jsx)(n.code,{children:"SUCCESS"})," on the server and ",(0,t.jsx)(n.code,{children:"CONSUME"})," on the client."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"InteractionResultHolder<T>"})," is a wrapper around ",(0,t.jsx)(n.code,{children:"InteractionResult"})," that adds additional context for ",(0,t.jsx)(n.code,{children:"T"}),". ",(0,t.jsx)(n.code,{children:"T"})," can be anything, but in 99.99 percent of cases, it is an ",(0,t.jsx)(n.code,{children:"ItemStack"}),". ",(0,t.jsx)(n.code,{children:"InteractionResultHolder<T>"})," provides wrapper methods for the enum values (",(0,t.jsx)(n.code,{children:"#success"}),", ",(0,t.jsx)(n.code,{children:"#consume"}),", ",(0,t.jsx)(n.code,{children:"#pass"})," and ",(0,t.jsx)(n.code,{children:"#fail"}),"), as well as ",(0,t.jsx)(n.code,{children:"#sidedSuccess"}),", which calls ",(0,t.jsx)(n.code,{children:"#success"})," on the server and ",(0,t.jsx)(n.code,{children:"#consume"})," on the client."]}),"\n",(0,t.jsx)(n.p,{children:"Generally, the different values mean the following:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"InteractionResult#sidedSuccess"})," (or ",(0,t.jsx)(n.code,{children:"InteractionResultHolder#sidedSuccess"})," where needed) should be used if the operation should be considered successful, and you want the arm to swing. The pipeline will end."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"InteractionResult.SUCCESS"})," (or ",(0,t.jsx)(n.code,{children:"InteractionResultHolder#success"})," where needed) should be used if the operation should be considered successful, and you want the arm to swing, but only on one side. Only use this if you want to return a different value on the other logical side for whatever reason. The pipeline will end."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"InteractionResult.CONSUME"})," (or ",(0,t.jsx)(n.code,{children:"InteractionResultHolder#consume"})," where needed) should be used if the operation should be considered successful, but you do not want the arm to swing. The pipeline will end."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"InteractionResult.CONSUME_PARTIAL"})," is mostly identical to ",(0,t.jsx)(n.code,{children:"InteractionResult.CONSUME"}),", the only difference is in its usage in ",(0,t.jsx)(n.a,{href:"#itemuseon",children:(0,t.jsx)(n.code,{children:"Item#useOn"})}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"InteractionResult.FAIL"})," (or ",(0,t.jsx)(n.code,{children:"InteractionResultHolder#fail"})," where needed) should be used if the item functionality should be considered failed and no further interaction should be performed. The pipeline will end. This can be used everywhere, but it should be used with care outside of ",(0,t.jsx)(n.code,{children:"Item#useOn"})," and ",(0,t.jsx)(n.code,{children:"Item#use"}),". In many cases, using ",(0,t.jsx)(n.code,{children:"InteractionResult.PASS"})," makes more sense."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"InteractionResult.PASS"})," (or ",(0,t.jsx)(n.code,{children:"InteractionResultHolder#pass"})," where needed) should be used if the operation should be considered neither successful nor failed. The pipeline will continue. This is the default behavior (unless otherwise specified)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Some methods have special behavior or requirements, which are explained in the below chapters."}),"\n",(0,t.jsx)(n.h2,{id:"iitemextensiononitemusefirst",children:(0,t.jsx)(n.code,{children:"IItemExtension#onItemUseFirst"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"InteractionResult#sidedSuccess"})," and ",(0,t.jsx)(n.code,{children:"InteractionResult.CONSUME"})," don't have an effect here. Only ",(0,t.jsx)(n.code,{children:"InteractionResult.SUCCESS"}),", ",(0,t.jsx)(n.code,{children:"InteractionResult.FAIL"})," or ",(0,t.jsx)(n.code,{children:"InteractionResult.PASS"})," should be used here."]}),"\n",(0,t.jsx)(n.h2,{id:"itemuseon",children:(0,t.jsx)(n.code,{children:"Item#useOn"})}),"\n",(0,t.jsxs)(n.p,{children:["If you want the operation to be considered successful, but you do not want the arm to swing or an ",(0,t.jsx)(n.code,{children:"ITEM_USED"})," stat point to be awarded, use ",(0,t.jsx)(n.code,{children:"InteractionResult.CONSUME_PARTIAL"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"itemuse",children:(0,t.jsx)(n.code,{children:"Item#use"})}),"\n",(0,t.jsxs)(n.p,{children:["This is the only instance where the return type is ",(0,t.jsx)(n.code,{children:"InteractionResultHolder<ItemStack>"}),". The resulting ",(0,t.jsx)(n.code,{children:"ItemStack"})," in the ",(0,t.jsx)(n.code,{children:"InteractionResultHolder<ItemStack>"})," replaces the ",(0,t.jsx)(n.code,{children:"ItemStack"})," the usage was initiated with, if it has changed."]}),"\n",(0,t.jsxs)(n.p,{children:["The default implementation of ",(0,t.jsx)(n.code,{children:"Item#use"})," returns ",(0,t.jsx)(n.code,{children:"InteractionResultHolder#consume"})," when the item is edible and the player can eat the item (because they are hungry, or because the item is always edible), ",(0,t.jsx)(n.code,{children:"InteractionResultHolder#fail"})," when the item is edible but the player cannot eat the item, and ",(0,t.jsx)(n.code,{children:"InteractionResultHolder#pass"})," if the item is not edible."]}),"\n",(0,t.jsxs)(n.p,{children:["Returning ",(0,t.jsx)(n.code,{children:"InteractionResultHolder#fail"})," here while considering the main hand will prevent offhand behavior from running. If you want offhand behavior to run (which you usually want), return ",(0,t.jsx)(n.code,{children:"InteractionResultHolder#pass"})," instead."]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>d,a:()=>o});var t=i(7294);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);