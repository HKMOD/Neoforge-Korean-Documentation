"use strict";(self.webpackChunkneoforged_docs=self.webpackChunkneoforged_docs||[]).push([[847],{6035:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var i=t(5893),a=t(1151);const o={},r="Using Configuration Tasks",s={id:"networking/configuration-tasks",title:"Using Configuration Tasks",description:"The networking protocol for the client and server has a specific phase where the server can configure the client before the player actually joins the game.",source:"@site/versioned_docs/version-1.20.4/networking/configuration-tasks.md",sourceDirName:"networking",slug:"/networking/configuration-tasks",permalink:"/Neoforge-Korean-Documentation/docs/1.20.4/networking/configuration-tasks",draft:!1,unlisted:!1,tags:[],version:"1.20.4",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Networking",permalink:"/Neoforge-Korean-Documentation/docs/1.20.4/networking/"},next:{title:"Entities",permalink:"/Neoforge-Korean-Documentation/docs/1.20.4/networking/entities"}},c={},l=[{value:"Registering a configuration task",id:"registering-a-configuration-task",level:2},{value:"Implementing a configuration task",id:"implementing-a-configuration-task",level:2},{value:"Acknowledging a configuration task",id:"acknowledging-a-configuration-task",level:2},{value:"Capturing the listener",id:"capturing-the-listener",level:3},{value:"Acknowledging the configuration task",id:"acknowledging-the-configuration-task",level:3},{value:"Stalling the login process",id:"stalling-the-login-process",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"using-configuration-tasks",children:"Using Configuration Tasks"}),"\n",(0,i.jsx)(n.p,{children:"The networking protocol for the client and server has a specific phase where the server can configure the client before the player actually joins the game.\nThis phase is called the configuration phase, and is for example used by the vanilla server to send the resource pack information to the client."}),"\n",(0,i.jsx)(n.p,{children:"This phase can also be used by mods to configure the client before the player joins the game."}),"\n",(0,i.jsx)(n.h2,{id:"registering-a-configuration-task",children:"Registering a configuration task"}),"\n",(0,i.jsxs)(n.p,{children:["The first step to using the configuration phase is to register a configuration task.\nThis can be done by registering a new configuration task in the ",(0,i.jsx)(n.code,{children:"OnGameConfigurationEvent"})," event."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@SubscribeEvent\npublic static void register(final OnGameConfigurationEvent event) {\n    event.register(new MyConfigurationTask());\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"OnGameConfigurationEvent"})," event is fired on the mod bus, and exposes the current listener used by the server to configure the relevant client.\nA modder can use the exposed listener to figure out if the client is running the mod, and if so, register a configuration task."]}),"\n",(0,i.jsx)(n.h2,{id:"implementing-a-configuration-task",children:"Implementing a configuration task"}),"\n",(0,i.jsxs)(n.p,{children:["A configuration task is a simple interface: ",(0,i.jsx)(n.code,{children:"ICustomConfigurationTask"}),".\nThis interface has two methods: ",(0,i.jsx)(n.code,{children:"void run(Consumer<CustomPacketPayload> sender);"}),", and ",(0,i.jsx)(n.code,{children:"ConfigurationTask.Type type();"})," which returns the type of the configuration task.\nThe type is used to identify the configuration task.\nAn example of a configuration task is shown below:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public record MyConfigurationTask implements ICustomConfigurationTask {\n    public static final ConfigurationTask.Type TYPE = new ConfigurationTask.Type(new ResourceLocation("mymod:my_task"));\n    \n    @Override\n    public void run(final Consumer<CustomPacketPayload> sender) {\n        final MyData payload = new MyData();\n        sender.accept(payload);\n    }\n\n    @Override\n    public ConfigurationTask.Type type() {\n        return TYPE;\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"acknowledging-a-configuration-task",children:"Acknowledging a configuration task"}),"\n",(0,i.jsx)(n.p,{children:"Your configuration is executed on the server, and the server needs to know when the next configuration task can be executed.\nThis is done by acknowledging the execution of said configuration task."}),"\n",(0,i.jsx)(n.p,{children:"There are two primary ways of achieving this:"}),"\n",(0,i.jsx)(n.h3,{id:"capturing-the-listener",children:"Capturing the listener"}),"\n",(0,i.jsx)(n.p,{children:"When the client does not need to acknowledge the configuration task, then the listener can be captured, and the configuration task can be acknowledged directly on the server side."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public record MyConfigurationTask(ServerConfigurationListener listener) implements ICustomConfigurationTask {\n    public static final ConfigurationTask.Type TYPE = new ConfigurationTask.Type(new ResourceLocation("mymod:my_task"));\n    \n    @Override\n    public void run(final Consumer<CustomPacketPayload> sender) {\n        final MyData payload = new MyData();\n        sender.accept(payload);\n        listener.finishCurrentTask(type());\n    }\n\n    @Override\n    public ConfigurationTask.Type type() {\n        return TYPE;\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To use such a configuration task, the listener needs to be captured in the ",(0,i.jsx)(n.code,{children:"OnGameConfigurationEvent"})," event."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@SubscribeEvent\npublic static void register(final OnGameConfigurationEvent event) {\n    event.register(new MyConfigurationTask(event.listener()));\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then the next configuration task will be executed immediately after the current configuration task has completed, and the client does not need to acknowledge the configuration task.\nAdditionally, the server will not wait for the client to properly process the send payloads."}),"\n",(0,i.jsx)(n.h3,{id:"acknowledging-the-configuration-task",children:"Acknowledging the configuration task"}),"\n",(0,i.jsx)(n.p,{children:"When the client needs to acknowledge the configuration task, then you will need to send your own payload to the client:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public record AckPayload() implements CustomPacketPayload {\n    public static final ResourceLocation ID = new ResourceLocation("mymod:ack");\n    \n    @Override\n    public void write(final FriendlyByteBuf buffer) {\n        // No data to write\n    }\n\n    @Override\n    public ResourceLocation id() {\n        return ID;\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"When a payload from a server side configuration task is properly processed you can send this payload to the server to acknowledge the configuration task."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public void onMyData(MyData data, ConfigurationPayloadContext context) {\n    context.submitAsync(() -> {\n        blah(data.name());\n    })\n    .exceptionally(e -> {\n        // Handle exception\n        context.packetHandler().disconnect(Component.translatable("my_mod.configuration.failed", e.getMessage()));\n        return null;\n    })\n    .thenAccept(v -> {\n        context.replyHandler().send(new AckPayload());\n    });     \n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Where ",(0,i.jsx)(n.code,{children:"onMyData"})," is the handler for the payload that was sent by the server side configuration task."]}),"\n",(0,i.jsx)(n.p,{children:"When the server receives this payload it will acknowledge the configuration task, and the next configuration task will be executed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public void onAck(AckPayload payload, ConfigurationPayloadContext context) {\n    context.taskCompletedHandler().onTaskCompleted(MyConfigurationTask.TYPE);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Where ",(0,i.jsx)(n.code,{children:"onAck"})," is the handler for the payload that was sent by the client."]}),"\n",(0,i.jsx)(n.h2,{id:"stalling-the-login-process",children:"Stalling the login process"}),"\n",(0,i.jsx)(n.p,{children:"When the configuration is not acknowledged, then the server will wait forever, and the client will never join the game.\nSo it is important to always acknowledge the configuration task, unless the configuration task failed, then you can disconnect the client."})]})}function u(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>r});var i=t(7294);const a={},o=i.createContext(a);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);