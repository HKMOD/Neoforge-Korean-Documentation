"use strict";(self.webpackChunkneoforged_docs=self.webpackChunkneoforged_docs||[]).push([[1297],{4919:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>l});var s=t(5893),i=t(1151);const r={},o="Events",d={id:"concepts/events",title:"Events",description:"One of NeoForge's main features is the event system. Events are fired for various things that happen in the game. For example, there are events for when the player right clicks, when a player or another entity jumps, when blocks are rendered, when the game is loaded, etc. A modder can subscribe event handlers to each of these events, and then perform their desired behavior inside these event handlers.",source:"@site/versioned_docs/version-1.20.4/concepts/events.md",sourceDirName:"concepts",slug:"/concepts/events",permalink:"/Neoforge-Korean-Documentation/docs/1.20.4/concepts/events",draft:!1,unlisted:!1,tags:[],version:"1.20.4",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Blockstates",permalink:"/Neoforge-Korean-Documentation/docs/1.20.4/blocks/states"},next:{title:"Registries",permalink:"/Neoforge-Korean-Documentation/docs/1.20.4/concepts/registries"}},a={},l=[{value:"Registering an Event Handler",id:"registering-an-event-handler",level:2},{value:"<code>IEventBus#addListener</code>",id:"ieventbusaddlistener",level:3},{value:"<code>@SubscribeEvent</code>",id:"subscribeevent",level:3},{value:"<code>@Mod.EventBusSubscriber</code>",id:"modeventbussubscriber",level:3},{value:"Event Options",id:"event-options",level:2},{value:"Fields and Methods",id:"fields-and-methods",level:3},{value:"Hierarchy",id:"hierarchy",level:3},{value:"Cancellable Events",id:"cancellable-events",level:3},{value:"Results",id:"results",level:3},{value:"Priority",id:"priority",level:3},{value:"Sided Events",id:"sided-events",level:3},{value:"Event Buses",id:"event-buses",level:2},{value:"The Mod Lifecycle",id:"the-mod-lifecycle",level:3},{value:"<code>InterModComms</code>",id:"intermodcomms",level:4},{value:"Other Mod Bus Events",id:"other-mod-bus-events",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"events",children:"Events"}),"\n",(0,s.jsx)(n.p,{children:"One of NeoForge's main features is the event system. Events are fired for various things that happen in the game. For example, there are events for when the player right clicks, when a player or another entity jumps, when blocks are rendered, when the game is loaded, etc. A modder can subscribe event handlers to each of these events, and then perform their desired behavior inside these event handlers."}),"\n",(0,s.jsxs)(n.p,{children:["Events are fired on their respective event bus. The most important bus is ",(0,s.jsx)(n.code,{children:"NeoForge.EVENT_BUS"}),". Besides that, during startup, a mod bus is spawned for each loaded mod and passed into the mod's constructor. Many mod bus events are fired in parallel (as opposed to main bus events that always run on the same thread), dramatically increasing startup speed. See ",(0,s.jsx)(n.a,{href:"#event-buses",children:"below"})," for more information."]}),"\n",(0,s.jsx)(n.h2,{id:"registering-an-event-handler",children:"Registering an Event Handler"}),"\n",(0,s.jsxs)(n.p,{children:["There are multiple ways to register event handlers. Common for all of those ways is that every event handler is a method with a single event parameter and no result (i.e. return type ",(0,s.jsx)(n.code,{children:"void"}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"ieventbusaddlistener",children:(0,s.jsx)(n.code,{children:"IEventBus#addListener"})}),"\n",(0,s.jsx)(n.p,{children:"The simplest way to register method handlers is by registering their method reference, like so:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Mod("yourmodid")\npublic class YourMod {\n    public YourMod(IEventBus modBus) {\n        NeoForge.EVENT_BUS.addListener(YourMod::onLivingJump);\n    }\n\n    // Heals an entity by half a heart every time they jump.\n    private static void onLivingJump(LivingJumpEvent event) {\n        Entity entity = event.getEntity();\n        // Only heal on the server side\n        if (!entity.level().isClientSide()) {\n            entity.heal(1);\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"subscribeevent",children:(0,s.jsx)(n.code,{children:"@SubscribeEvent"})}),"\n",(0,s.jsxs)(n.p,{children:["Alternatively, event handlers can be annotation-driven by creating an event handler method and annotating it with ",(0,s.jsx)(n.code,{children:"@SubscribeEvent"}),". Then, you can pass an instance of the encompassing class to the event bus, registering all ",(0,s.jsx)(n.code,{children:"@SubscribeEvent"}),"-annotated event handlers of that instance:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class EventHandler {\n    @SubscribeEvent\n    public void onLivingJump(LivingJumpEvent event) {\n        Entity entity = event.getEntity();\n        if (!entity.level().isClientSide()) {\n            entity.heal(1);\n        }\n    }\n}\n\n@Mod("yourmodid")\npublic class YourMod {\n    public YourMod(IEventBus modBus) {\n        NeoForge.EVENT_BUS.addListener(new EventHandler());\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"You can also do it statically. Simply make all event handlers static, and instead of a class instance, pass in the class itself:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class EventHandler {\n\t@SubscribeEvent\n    public static void onLivingJump(LivingJumpEvent event) {\n        Entity entity = event.getEntity();\n        if (!entity.level().isClientSide()) {\n            entity.heal(1);\n        }\n    }\n}\n\n@Mod("yourmodid")\npublic class YourMod {\n    public YourMod(IEventBus modBus) {\n        NeoForge.EVENT_BUS.addListener(EventHandler.class);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"modeventbussubscriber",children:(0,s.jsx)(n.code,{children:"@Mod.EventBusSubscriber"})}),"\n",(0,s.jsxs)(n.p,{children:["We can go one step further and also annotate the event handler class with ",(0,s.jsx)(n.code,{children:"@Mod.EventBusSubscriber"}),". This annotation is discovered automatically by NeoForge, allowing you to remove all event-related code from the mod constructor. In essence, it is equivalent to calling ",(0,s.jsx)(n.code,{children:"NeoForge.EVENT_BUS.register(EventHandler.class)"})," at the end of the mod constructor. This means that all handlers must be static, too."]}),"\n",(0,s.jsxs)(n.p,{children:["While not required, it is highly recommended to specify the ",(0,s.jsx)(n.code,{children:"modid"})," parameter in the annotation, in order to make debugging easier (especially when it comes to mod conflicts)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Mod.EventBusSubscriber(modid = "yourmodid")\npublic class EventHandler {\n    @SubscribeEvent\n    public static void onLivingJump(LivingJumpEvent event) {\n        Entity entity = event.getEntity();\n        if (!entity.level().isClientSide()) {\n            entity.heal(1);\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"event-options",children:"Event Options"}),"\n",(0,s.jsx)(n.h3,{id:"fields-and-methods",children:"Fields and Methods"}),"\n",(0,s.jsx)(n.p,{children:"Fields and methods are probably the most obvious part of an event. Most events contain context for the event handler to use, such as an entity causing the event or a level the event occurs in."}),"\n",(0,s.jsx)(n.h3,{id:"hierarchy",children:"Hierarchy"}),"\n",(0,s.jsxs)(n.p,{children:["In order to use the advantages of inheritance, some events do not directly extend ",(0,s.jsx)(n.code,{children:"Event"}),", but one of its subclasses, for example ",(0,s.jsx)(n.code,{children:"BlockEvent"})," (which contains block context for block-related events) or ",(0,s.jsx)(n.code,{children:"EntityEvent"})," (which similarly contains entity context) and its subclasses ",(0,s.jsx)(n.code,{children:"LivingEvent"})," (for ",(0,s.jsx)(n.code,{children:"LivingEntity"}),"-specific context) and ",(0,s.jsx)(n.code,{children:"PlayerEvent"})," (for ",(0,s.jsx)(n.code,{children:"Player"}),"-specific context). These context-providing super events are ",(0,s.jsx)(n.code,{children:"abstract"})," and cannot be listened to."]}),"\n",(0,s.jsx)(n.admonition,{type:"danger",children:(0,s.jsxs)(n.p,{children:["If you listen to an ",(0,s.jsx)(n.code,{children:"abstract"})," event, your game will crash, as this is never what you want. You always want to listen to one of the subevents instead."]})}),"\n",(0,s.jsx)(n.h3,{id:"cancellable-events",children:"Cancellable Events"}),"\n",(0,s.jsxs)(n.p,{children:["Some events implement the ",(0,s.jsx)(n.code,{children:"ICancellableEvent"})," interface. These events can be cancelled using ",(0,s.jsx)(n.code,{children:"#setCanceled(boolean canceled)"}),", and the cancellation status can be checked using ",(0,s.jsx)(n.code,{children:"#isCanceled()"}),'. If an event is cancelled, other event handlers for this event will not run, and some kind of behavior that is associated with "cancelling" is enabled. For example, cancelling ',(0,s.jsx)(n.code,{children:"LivingJumpEvent"})," will prevent the jump."]}),"\n",(0,s.jsxs)(n.p,{children:["Event handlers can opt to explicitly receive cancelled events. This is done by setting the ",(0,s.jsx)(n.code,{children:"receiveCanceled"})," parameter in ",(0,s.jsx)(n.code,{children:"IEventBus#addListener"})," (or ",(0,s.jsx)(n.code,{children:"@SubscribeEvent"}),", depending on your way of attaching the event handlers) to true."]}),"\n",(0,s.jsx)(n.h3,{id:"results",children:"Results"}),"\n",(0,s.jsxs)(n.p,{children:["Some events have a ",(0,s.jsx)(n.code,{children:"Result"}),". A ",(0,s.jsx)(n.code,{children:"Result"})," can be one of three things: ",(0,s.jsx)(n.code,{children:"DENY"})," which stops the event, ",(0,s.jsx)(n.code,{children:"ALLOW"})," which force-runs the event, and ",(0,s.jsx)(n.code,{children:"DEFAULT"})," which uses the Vanilla behavior. The result of an event can be set by calling ",(0,s.jsx)(n.code,{children:"Event#setResult"}),". Not all events have results; an event with a result will be annotated with ",(0,s.jsx)(n.code,{children:"@HasResult"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsx)(n.p,{children:"Results are deprecated and will be replaced by more specific per-event results soon."})}),"\n",(0,s.jsx)(n.h3,{id:"priority",children:"Priority"}),"\n",(0,s.jsxs)(n.p,{children:["Event handlers can optionally get assigned a priority. The ",(0,s.jsx)(n.code,{children:"EventPriority"})," enum contains five values: ",(0,s.jsx)(n.code,{children:"HIGHEST"}),", ",(0,s.jsx)(n.code,{children:"HIGH"}),", ",(0,s.jsx)(n.code,{children:"NORMAL"})," (default), ",(0,s.jsx)(n.code,{children:"LOW"})," and ",(0,s.jsx)(n.code,{children:"LOWEST"}),". Event handlers are executed from highest to lowest priority. If they have the same priority, they fire in registration order on the main bus, which is roughly related to mod load order, and in exact mod load order on the mod bus (see below)."]}),"\n",(0,s.jsxs)(n.p,{children:["Priorities can be defined by setting the ",(0,s.jsx)(n.code,{children:"priority"})," parameter in ",(0,s.jsx)(n.code,{children:"IEventBus#addListener"})," or ",(0,s.jsx)(n.code,{children:"@SubscribeEvent"}),", depending on how you attach event handlers. Note that priorities are ignored for events that are fired in parallel."]}),"\n",(0,s.jsx)(n.h3,{id:"sided-events",children:"Sided Events"}),"\n",(0,s.jsxs)(n.p,{children:["Some events are only fired on one ",(0,s.jsx)(n.a,{href:"/Neoforge-Korean-Documentation/docs/1.20.4/concepts/sides",children:"side"}),". Common examples include the various render events, which are only fired on the client. Since client-only events generally need to access other client-only parts of the Minecraft codebase, they need to be registered accordingly."]}),"\n",(0,s.jsxs)(n.p,{children:["Event handlers that use ",(0,s.jsx)(n.code,{children:"IEventBus#addListener()"})," should use a ",(0,s.jsx)(n.code,{children:"FMLEnvironment.dist"})," check and a separate client-only class, as outlined in the article on sides."]}),"\n",(0,s.jsxs)(n.p,{children:["Event handlers that use ",(0,s.jsx)(n.code,{children:"@Mod.EventBusSubscriber"})," can specify the side as the ",(0,s.jsx)(n.code,{children:"value"})," parameter of the annotation, for example ",(0,s.jsx)(n.code,{children:'@Mod.EventBusSubscriber(value = Dist.CLIENT, modid = "yourmodid")'}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"event-buses",children:"Event Buses"}),"\n",(0,s.jsxs)(n.p,{children:["While most events are posted on the ",(0,s.jsx)(n.code,{children:"NeoForge.EVENT_BUS"}),", some events are posted on the mod event bus instead. These are generally called mod bus events. Mod bus events can be distinguished from regular events by their superinterface ",(0,s.jsx)(n.code,{children:"IModBusEvent"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The mod event bus is passed to you as a parameter in the mod constructor, and you can then subscribe mod bus events to it. If you use ",(0,s.jsx)(n.code,{children:"@Mod.EventBusSubscriber"}),", you can also set the bus as an annotation parameter, like so: ",(0,s.jsx)(n.code,{children:'@Mod.EventBusSubscriber(bus = Bus.MOD, modid = "yourmodid")'}),". The default bus is ",(0,s.jsx)(n.code,{children:"Bus.FORGE"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"the-mod-lifecycle",children:"The Mod Lifecycle"}),"\n",(0,s.jsxs)(n.p,{children:["Most mod bus events are what is known as lifecycle events. Lifecycle events run once in every mod's lifecycle during startup. Many of them are fired in parallel; if you want to run code from one of these events on the main thread, enqueue them using ",(0,s.jsx)(n.code,{children:"#enqueueWork(Runnable runnable)"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The lifecycle generally follows the following order:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The mod constructor is called. Register your event handlers here, or in the next step."}),"\n",(0,s.jsxs)(n.li,{children:["All ",(0,s.jsx)(n.code,{children:"@Mod.EventBusSubscriber"}),"s are called."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FMLConstructModEvent"})," is fired."]}),"\n",(0,s.jsxs)(n.li,{children:["The registry events are fired, these include ",(0,s.jsx)(n.a,{href:"/Neoforge-Korean-Documentation/docs/1.20.4/concepts/registries#custom-registries",children:(0,s.jsx)(n.code,{children:"NewRegistryEvent"})}),", ",(0,s.jsx)(n.a,{href:"/Neoforge-Korean-Documentation/docs/1.20.4/concepts/registries#custom-datapack-registries",children:(0,s.jsx)(n.code,{children:"DataPackRegistryEvent.NewRegistry"})})," and, for each registry, ",(0,s.jsx)(n.a,{href:"/Neoforge-Korean-Documentation/docs/1.20.4/concepts/registries#registerevent",children:(0,s.jsx)(n.code,{children:"RegisterEvent"})}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FMLCommonSetupEvent"})," is fired. This is where various miscellaneous setup happens."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.a,{href:"/Neoforge-Korean-Documentation/docs/1.20.4/concepts/sides",children:"sided"})," setup is fired: ",(0,s.jsx)(n.code,{children:"FMLClientSetupEvent"})," if on a physical client, and ",(0,s.jsx)(n.code,{children:"FMLDedicatedServerSetupEvent"})," if on a physical server."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"InterModComms"})," are handled (see below)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FMLLoadCompleteEvent"})," is fired."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"intermodcomms",children:(0,s.jsx)(n.code,{children:"InterModComms"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"InterModComms"})," is a system that allows modders to send messages to other mods for compatibility features. The class holds the messages for mods, all methods are thread-safe to call. The system is mainly driven by two events: ",(0,s.jsx)(n.code,{children:"InterModEnqueueEvent"})," and ",(0,s.jsx)(n.code,{children:"InterModProcessEvent"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["During ",(0,s.jsx)(n.code,{children:"InterModEnqueueEvent"}),", you can use ",(0,s.jsx)(n.code,{children:"InterModComms#sendTo"})," to send messages to other mods. These methods accept the id of the mod to send the message to, the key associated with the message data (to distinguish between different messages), and a ",(0,s.jsx)(n.code,{children:"Supplier"})," holding the message data. The sender can be optionally specified as well."]}),"\n",(0,s.jsxs)(n.p,{children:["Then, during ",(0,s.jsx)(n.code,{children:"InterModProcessEvent"}),", you can use ",(0,s.jsx)(n.code,{children:"InterModComms#getMessages"})," to get a stream of all received messages as ",(0,s.jsx)(n.code,{children:"IMCMessage"})," objects. These hold the sender of the data, the intended receiver of the data, the data key, and the supplier for the actual data."]}),"\n",(0,s.jsx)(n.h3,{id:"other-mod-bus-events",children:"Other Mod Bus Events"}),"\n",(0,s.jsx)(n.p,{children:"Next to the lifecycle events, there are a few miscellaneous events that are fired on the mod event bus, mostly for legacy reasons. These are generally events where you can register, set up, or initialize various things. Most of these events are not ran in parallel in contrast to the lifecycle events. A few examples:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"RegisterColorHandlersEvent"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ModelEvent.BakingCompleted"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"TextureStitchEvent"})}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"Most of these events are planned to be moved to the main event bus in a future version."})})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>d,a:()=>o});var s=t(7294);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);